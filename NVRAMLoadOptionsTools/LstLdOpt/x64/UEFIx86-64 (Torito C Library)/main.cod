; Listing generated by Microsoft (R) Optimizing Compiler Version 19.24.28316.0 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	main
PUBLIC	??_C@_15MAOEGKJF@?$AA?$CF?$AAS@			; `string'
PUBLIC	??_C@_0CA@BEGOPMNG@Y?3?2Tools?2LstLdOpt?2main?4c?$CI?$CFd?$CJ?$CFS?6@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_05HKKFJEBI@?$CFS?5?3?5@			; `string'
PUBLIC	??_C@_0DC@PHFFEDML@?$CF08X?9?$CF04X?9?$CF04X?9?$CF02X?$CF02X?9?$CF02X?$CF02@ ; `string'
PUBLIC	??_C@_0BG@KJDAMLHL@driver?5start?5rejected@	; `string'
PUBLIC	??_C@_0BL@EBANBOLM@driver?5started?5during?5POST@ ; `string'
PUBLIC	??_C@_0BJ@FBPIPPHE@?$CFs?5?9?$DO?5CommandLine?3?5?$CC?$CFs?$CC?6@ ; `string'
EXTRN	swprintf:PROC
EXTRN	printf:PROC
EXTRN	malloc:PROC
EXTRN	memset:PROC
EXTRN	wcscpy:PROC
EXTRN	wcsncmp:PROC
EXTRN	strlen:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN19
	DD	imagerel $LN19+483
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT ??_C@_0BJ@FBPIPPHE@?$CFs?5?9?$DO?5CommandLine?3?5?$CC?$CFs?$CC?6@
CONST	SEGMENT
??_C@_0BJ@FBPIPPHE@?$CFs?5?9?$DO?5CommandLine?3?5?$CC?$CFs?$CC?6@ DB '%s '
	DB	'-> CommandLine: "%s"', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@EBANBOLM@driver?5started?5during?5POST@
CONST	SEGMENT
??_C@_0BL@EBANBOLM@driver?5started?5during?5POST@ DB 'driver started duri'
	DB	'ng POST', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KJDAMLHL@driver?5start?5rejected@
CONST	SEGMENT
??_C@_0BG@KJDAMLHL@driver?5start?5rejected@ DB 'driver start rejected', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@PHFFEDML@?$CF08X?9?$CF04X?9?$CF04X?9?$CF02X?$CF02X?9?$CF02X?$CF02@
CONST	SEGMENT
??_C@_0DC@PHFFEDML@?$CF08X?9?$CF04X?9?$CF04X?9?$CF02X?$CF02X?9?$CF02X?$CF02@ DB '%'
	DB	'08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05HKKFJEBI@?$CFS?5?3?5@
CONST	SEGMENT
??_C@_05HKKFJEBI@?$CFS?5?3?5@ DB '%S : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BEGOPMNG@Y?3?2Tools?2LstLdOpt?2main?4c?$CI?$CFd?$CJ?$CFS?6@
CONST	SEGMENT
??_C@_0CA@BEGOPMNG@Y?3?2Tools?2LstLdOpt?2main?4c?$CI?$CFd?$CJ?$CFS?6@ DB 'Y'
	DB	':\Tools\LstLdOpt\main.c(%d)%S', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_15MAOEGKJF@?$AA?$CF?$AAS@
CONST	SEGMENT
??_C@_15MAOEGKJF@?$AA?$CF?$AAS@ DB '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	0a1701H
	DD	0163417H
	DD	0f010d217H
	DD	0d00ce00eH
	DD	07008c00aH
	DD	050066007H
xdata	ENDS
; Function compile flags: /Ogspy
; File Y:\Tools\LstLdOpt\main.c
;	COMDAT main
_TEXT	SEGMENT
guid$ = 96
argc$ = 176
VarNameSize$ = 184
argv$ = 184
datasize$ = 192
pVarName2$1$ = 200
main	PROC						; COMDAT

; 17   : int main(int argc, char** argv) {

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	55		 push	 rbp
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	41 54		 push	 r12
  0000a	41 55		 push	 r13
  0000c	41 56		 push	 r14
  0000e	41 57		 push	 r15
  00010	48 8b ec	 mov	 rbp, rsp
  00013	48 83 ec 70	 sub	 rsp, 112		; 00000070H

; 18   : 
; 19   :     EFI_SYSTEM_TABLE* SystemTable = (EFI_SYSTEM_TABLE*)(argv[-1]);      //SystemTable is passed in argv[-1]

  00017	4c 8b 62 f8	 mov	 r12, QWORD PTR [rdx-8]

; 20   : //    EFI_HANDLE ImageHandle = (void*)(argv[-2]);                         //ImageHandle is passed in argv[-2]
; 21   :     EFI_STATUS Status = EFI_SUCCESS;
; 22   :     EFI_GUID guid;
; 23   :     int n;
; 24   :     int nRet = 1;
; 25   :     char fPrint = 1;
; 26   :     size_t len = argc > 1 ? 1 + strlen(argv[1]) : 0;

  0001b	33 f6		 xor	 esi, esi
  0001d	48 8b da	 mov	 rbx, rdx
  00020	83 f9 01	 cmp	 ecx, 1
  00023	7e 0f		 jle	 SHORT $LN11@main
  00025	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00029	e8 00 00 00 00	 call	 strlen
  0002e	4c 8d 70 01	 lea	 r14, QWORD PTR [rax+1]
  00032	eb 03		 jmp	 SHORT $LN12@main
$LN11@main:
  00034	4c 8b f6	 mov	 r14, rsi
$LN12@main:

; 27   :     wchar_t* pVarName        = malloc(BSIZE);

  00037	41 bd 00 10 00
	00		 mov	 r13d, 4096		; 00001000H
  0003d	41 8b cd	 mov	 ecx, r13d
  00040	e8 00 00 00 00	 call	 malloc

; 28   :     wchar_t* pVarName2       = malloc(BSIZE);

  00045	41 8b cd	 mov	 ecx, r13d
  00048	4c 8b f8	 mov	 r15, rax
  0004b	e8 00 00 00 00	 call	 malloc

; 29   :     NVRAMCOMMANDLINE* pNvram = malloc(BSIZE);

  00050	41 8b cd	 mov	 ecx, r13d
  00053	48 89 45 58	 mov	 QWORD PTR pVarName2$1$[rbp-112], rax
  00057	48 8b f8	 mov	 rdi, rax
  0005a	e8 00 00 00 00	 call	 malloc

; 30   :     size_t datasize = BSIZE;
; 31   :     size_t VarNameSize = BSIZE;
; 32   : 
; 33   :     memset(&guid, 0, sizeof(guid));

  0005f	33 d2		 xor	 edx, edx
  00061	48 c7 45 50 00
	10 00 00	 mov	 QWORD PTR datasize$[rbp-112], 4096 ; 00001000H
  00069	48 8d 4d f0	 lea	 rcx, QWORD PTR guid$[rbp-112]
  0006d	4c 8b e8	 mov	 r13, rax
  00070	44 8d 42 10	 lea	 r8d, QWORD PTR [rdx+16]
  00074	e8 00 00 00 00	 call	 memset

; 34   :     
; 35   :     swprintf(pVarName2, len, L"%S", argv[1]);

  00079	4c 8b 4b 08	 mov	 r9, QWORD PTR [rbx+8]
  0007d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_15MAOEGKJF@?$AA?$CF?$AAS@
  00084	49 8b d6	 mov	 rdx, r14
  00087	48 8b cf	 mov	 rcx, rdi
  0008a	e8 00 00 00 00	 call	 swprintf

; 36   :     printf(__FILE__"(%d)""%S\n", __LINE__, pVarName2);

  0008f	4c 8b c7	 mov	 r8, rdi
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CA@BEGOPMNG@Y?3?2Tools?2LstLdOpt?2main?4c?$CI?$CFd?$CJ?$CFS?6@
  00099	ba 24 00 00 00	 mov	 edx, 36			; 00000024H
  0009e	e8 00 00 00 00	 call	 printf

; 37   :     wcscpy(pVarName, L"");

  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_11LOCGONAA@@
  000aa	49 8b cf	 mov	 rcx, r15
  000ad	e8 00 00 00 00	 call	 wcscpy
$LL4@main:

; 38   : 
; 39   :     do {
; 40   :         VarNameSize = BSIZE;

  000b2	48 c7 45 48 00
	10 00 00	 mov	 QWORD PTR VarNameSize$[rbp-112], 4096 ; 00001000H

; 41   :         Status = SystemTable->RuntimeServices->GetNextVariableName(

  000ba	4c 8d 45 f0	 lea	 r8, QWORD PTR guid$[rbp-112]
  000be	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  000c3	48 8d 4d 48	 lea	 rcx, QWORD PTR VarNameSize$[rbp-112]
  000c7	49 8b d7	 mov	 rdx, r15
  000ca	ff 50 50	 call	 QWORD PTR [rax+80]

; 42   :             &VarNameSize,
; 43   :             pVarName,
; 44   :             &guid
; 45   :         );
; 46   : 
; 47   :         if ((Status != EFI_SUCCESS)) {

  000cd	48 85 c0	 test	 rax, rax
  000d0	0f 85 f0 00 00
	00		 jne	 $LN3@main

; 48   :             break;
; 49   :             fprintf(stderr, __FILE__"%d): ""%s\n", __LINE__, strefierror(Status));
; 50   :         }
; 51   :         
; 52   :         if (len) {

  000d6	4d 85 f6	 test	 r14, r14
  000d9	74 16		 je	 SHORT $LN6@main

; 53   :             fPrint = !wcsncmp(pVarName2, pVarName,len-1);

  000db	4d 8d 46 ff	 lea	 r8, QWORD PTR [r14-1]
  000df	49 8b d7	 mov	 rdx, r15
  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	e8 00 00 00 00	 call	 wcsncmp
  000ea	85 c0		 test	 eax, eax
  000ec	0f 94 c0	 sete	 al

; 54   :             //printf(__FILE__"(%d): ""%S vs. %S, len == %d, fPrint == %d\n", __LINE__, pVarName2, pVarName, len, fPrint);
; 55   :         }

  000ef	eb 02		 jmp	 SHORT $LN7@main
$LN6@main:

; 56   :         else {
; 57   :             fPrint = 1;

  000f1	b0 01		 mov	 al, 1
$LN7@main:

; 58   :         }
; 59   : 
; 60   :         if (Status == EFI_SUCCESS && fPrint == 1) {

  000f3	3c 01		 cmp	 al, 1
  000f5	75 bb		 jne	 SHORT $LL4@main

; 61   :             pVarName[VarNameSize] = '\0';

  000f7	48 8b 45 48	 mov	 rax, QWORD PTR VarNameSize$[rbp-112]

; 62   :             printf("%S : ", pVarName);

  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05HKKFJEBI@?$CFS?5?3?5@
  00102	49 8b d7	 mov	 rdx, r15
  00105	66 41 89 34 47	 mov	 WORD PTR [r15+rax*2], si
  0010a	e8 00 00 00 00	 call	 printf

; 63   :             printf("%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X\n",

  0010f	0f b6 4d fe	 movzx	 ecx, BYTE PTR guid$[rbp-98]
  00113	0f b6 55 fd	 movzx	 edx, BYTE PTR guid$[rbp-99]
  00117	0f b6 45 ff	 movzx	 eax, BYTE PTR guid$[rbp-97]
  0011b	44 0f b6 55 fc	 movzx	 r10d, BYTE PTR guid$[rbp-100]
  00120	44 0f b6 5d fb	 movzx	 r11d, BYTE PTR guid$[rbp-101]
  00125	0f b6 5d fa	 movzx	 ebx, BYTE PTR guid$[rbp-102]
  00129	0f b6 7d f9	 movzx	 edi, BYTE PTR guid$[rbp-103]
  0012d	0f b6 75 f8	 movzx	 esi, BYTE PTR guid$[rbp-104]
  00131	44 0f b7 4d f6	 movzx	 r9d, WORD PTR guid$[rbp-106]
  00136	44 0f b7 45 f4	 movzx	 r8d, WORD PTR guid$[rbp-108]
  0013b	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0013f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0DC@PHFFEDML@?$CF08X?9?$CF04X?9?$CF04X?9?$CF02X?$CF02X?9?$CF02X?$CF02@
  0014a	89 54 24 48	 mov	 DWORD PTR [rsp+72], edx
  0014e	8b 55 f0	 mov	 edx, DWORD PTR guid$[rbp-112]
  00151	44 89 54 24 40	 mov	 DWORD PTR [rsp+64], r10d
  00156	44 89 5c 24 38	 mov	 DWORD PTR [rsp+56], r11d
  0015b	89 5c 24 30	 mov	 DWORD PTR [rsp+48], ebx
  0015f	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00163	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00167	e8 00 00 00 00	 call	 printf

; 64   :                 guid.Data1,
; 65   :                 guid.Data2,
; 66   :                 guid.Data3,
; 67   :                 guid.Data4[0],
; 68   :                 guid.Data4[1],
; 69   :                 guid.Data4[2],
; 70   :                 guid.Data4[3],
; 71   :                 guid.Data4[4],
; 72   :                 guid.Data4[5],
; 73   :                 guid.Data4[6],
; 74   :                 guid.Data4[7]);
; 75   : 
; 76   :             datasize = BSIZE;

  0016c	48 c7 45 50 00
	10 00 00	 mov	 QWORD PTR datasize$[rbp-112], 4096 ; 00001000H

; 77   :             Status = SystemTable->RuntimeServices->GetVariable(

  00174	4c 8d 4d 50	 lea	 r9, QWORD PTR datasize$[rbp-112]
  00178	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0017d	48 8d 55 f0	 lea	 rdx, QWORD PTR guid$[rbp-112]
  00181	45 33 c0	 xor	 r8d, r8d
  00184	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  00189	49 8b cf	 mov	 rcx, r15
  0018c	ff 50 48	 call	 QWORD PTR [rax+72]

; 78   :                 pVarName    /* IN CHAR16 * VariableName */,
; 79   :                 &guid       /* IN EFI_GUID * VendorGuid */,
; 80   :                 NULL        /* OUT UINT32 * Attributes OPTIONAL*/,
; 81   :                 &datasize    /* IN OUT UINTN * DataSize */,
; 82   :                 pNvram       /* OUT VOID * Data OPTIONAL*/
; 83   :             );
; 84   :             
; 85   :             //fprintf(stderr, __FILE__"%d): ""%s\n", __LINE__, strefierror(Status));
; 86   :             
; 87   :             if (EFI_SUCCESS == Status) {

  0018f	33 f6		 xor	 esi, esi
  00191	48 85 c0	 test	 rax, rax
  00194	75 30		 jne	 SHORT $LN3@main

; 88   :                 printf("%s -> CommandLine: \"%s\"\n", pNvram->rejectStart == 1 ? "driver start rejected" : "driver started during POST", pNvram->CommandLine);

  00196	41 83 7d 00 01	 cmp	 DWORD PTR [r13], 1
  0019b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@KJDAMLHL@driver?5start?5rejected@
  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@EBANBOLM@driver?5started?5during?5POST@
  001a9	48 0f 44 d0	 cmove	 rdx, rax
  001ad	4d 8d 45 04	 lea	 r8, QWORD PTR [r13+4]
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BJ@FBPIPPHE@?$CFs?5?9?$DO?5CommandLine?3?5?$CC?$CFs?$CC?6@
  001b8	e8 00 00 00 00	 call	 printf

; 89   :             }
; 90   : 
; 91   :         }
; 92   :     } while (Status == EFI_SUCCESS);

  001bd	48 8b 7d 58	 mov	 rdi, QWORD PTR pVarName2$1$[rbp-112]
  001c1	e9 ec fe ff ff	 jmp	 $LL4@main
$LN3@main:

; 93   : 
; 94   :     return nRet;
; 95   : }

  001c6	48 8b 9c 24 b0
	00 00 00	 mov	 rbx, QWORD PTR [rsp+176]
  001ce	b8 01 00 00 00	 mov	 eax, 1
  001d3	48 83 c4 70	 add	 rsp, 112		; 00000070H
  001d7	41 5f		 pop	 r15
  001d9	41 5e		 pop	 r14
  001db	41 5d		 pop	 r13
  001dd	41 5c		 pop	 r12
  001df	5f		 pop	 rdi
  001e0	5e		 pop	 rsi
  001e1	5d		 pop	 rbp
  001e2	c3		 ret	 0
main	ENDP
_TEXT	ENDS
END
